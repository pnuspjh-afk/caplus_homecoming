<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 공간 시각화 - 홈커밍 시뮬레이터</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Pretendard', sans-serif; background-color: #f5f5f5; }
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border-left: 5px solid #007AFF;
            z-index: 10;
        }
        h1 { margin: 0; font-size: 18px; color: #1a1a1a; letter-spacing: -0.5px; }
        
        #menu {
            margin-top: 12px;
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }
        button {
            background: #007AFF;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
            transition: background 0.2s;
        }
        button:hover { background: #0056b3; }
        
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 25px;
            border-radius: 50px;
            font-size: 13px;
            backdrop-filter: blur(5px);
            z-index: 10;
            text-align: center;
        }
        canvas { display: block; }
    </style>
</head>
<body>

    <div id="ui-overlay">
        <h1>홈커밍 시뮬레이터</h1>
        <div id="menu">
            <button onclick="addDesk()">+ 4인용 책상 추가</button>
        </div>
    </div>

    <div id="controls-hint">
        드래그: 화면 회전 / 휠: 확대<br>
        <b>조작:</b> 클릭 드래그로 이동 | R: 회전 | Del: 삭제
    </div>

    <script>
        let scene, camera, renderer, raycaster, mouse;
        let isMouseDown = false;
        let targetRotationX = 0.8, targetRotationY = -0.6;
        let zoom = 55;
        
        const desks = [];
        let selectedObject = null;
        let isDragging = false;
        const planeForDragging = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

        const ROOM_WIDTH = 10;
        const ROOM_DEPTH = 13;
        const COL_SIZE = 0.75; 

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f7fa);

            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true }); // Depth 버퍼 정밀도 향상
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(-15, 25, 15);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Floor
            const floorGeo = new THREE.PlaneGeometry(ROOM_WIDTH, ROOM_DEPTH);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            floor.name = "Floor";
            scene.add(floor);

            const edges = new THREE.EdgesGeometry(floorGeo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xcccccc }));
            line.rotation.x = -Math.PI / 2;
            line.position.y = 0.01;
            scene.add(line);

            setupEnvironment();
            setupLabels();
            setupInteractions();

            animate();
        }

        function setupEnvironment() {
            function createColumn(x, z, color = 0x666666) {
                const col = new THREE.Mesh(new THREE.BoxGeometry(COL_SIZE, 3.5, COL_SIZE), new THREE.MeshStandardMaterial({ color }));
                col.position.set(x, 1.75, z);
                col.castShadow = true;
                scene.add(col);
            }

            createColumn(4.625, -6.125); 
            createColumn(-1.125, -6.125);
            createColumn(4.625, -2.7, 0x007AFF); 
            createColumn(-1.125, -2.7);

            const mainScreen = new THREE.Mesh(new THREE.BoxGeometry(5, 2.5, 0.1), new THREE.MeshStandardMaterial({ color: 0x222222 }));
            mainScreen.position.set(1.75, 1.5, -6.45);
            scene.add(mainScreen);

            const kitchen = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.9, 0.8), new THREE.MeshStandardMaterial({ color: 0xdddddd }));
            kitchen.position.set(-3.25, 0.45, -6.1);
            scene.add(kitchen);

            const sideScreenGeo = new THREE.BoxGeometry(0.1, 2.0, 2.5);
            const sideScreenMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const ss1 = new THREE.Mesh(sideScreenGeo, sideScreenMat); ss1.position.set(4.95, 1.5, 0.5); scene.add(ss1);
            const ss2 = new THREE.Mesh(sideScreenGeo, sideScreenMat); ss2.position.set(4.95, 1.5, 3.75); scene.add(ss2);
            
            const fridge = new THREE.Mesh(new THREE.BoxGeometry(3.0, 2.1, 0.7), new THREE.MeshStandardMaterial({ color: 0xaaaaaa }));
            fridge.rotation.y = Math.PI / 2; fridge.position.set(-4.65, 1.05, -3.5); scene.add(fridge);

            const door = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 0.5), new THREE.MeshStandardMaterial({ color: 0x007AFF, side: THREE.DoubleSide }));
            door.rotation.x = -Math.PI / 2; door.position.set(3.5, 0.03, 6.5); scene.add(door);

            const counter = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.85, 0.6), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
            counter.position.set(1.9, 0.425, 6.2); scene.add(counter);

            const lounge = new THREE.Mesh(new THREE.BoxGeometry(2.6, 1.2, 1.2), new THREE.MeshStandardMaterial({ color: 0x444444, transparent: true, opacity: 0.6 }));
            lounge.position.set(-0.3, 0.6, 6.2); scene.add(lounge);

            const storage = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.5), new THREE.MeshStandardMaterial({ color: 0x555555, side: THREE.DoubleSide }));
            storage.rotation.x = -Math.PI / 2; storage.position.set(-2.5, 0.03, 6.5); scene.add(storage);

            const toiletDoor = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.5), new THREE.MeshStandardMaterial({ color: 0x88ccff, side: THREE.DoubleSide }));
            toiletDoor.rotation.x = -Math.PI / 2; toiletDoor.rotation.z = Math.PI / 2;
            toiletDoor.position.set(-4.8, 0.03, 5.5); scene.add(toiletDoor);
        }

        function createFixedLabel(text, x, y, z, options = {}) {
            // y 값을 미세하게 차등을 주어 겹침(Z-fighting) 방지
            const { color = "#000000", fontSize = 90, width = 1024, height = 256, rotation = [-Math.PI / 2, 0, 0], scale = [8, 2, 1] } = options;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // 고해상도 텍스트 처리를 위해 캔버스 스케일링
            canvas.width = width; canvas.height = height;
            ctx.clearRect(0, 0, width, height);
            
            ctx.font = `Bold ${fontSize}px Arial`;
            ctx.fillStyle = color; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            
            // 외곽선 추가로 시인성 확보
            ctx.strokeStyle = "rgba(255, 255, 255, 0.8)"; 
            ctx.lineWidth = 12;
            ctx.strokeText(text, width / 2, height / 2);
            ctx.fillText(text, width / 2, height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy(); // 텍스트 왜곡 방지
            
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), material);
            mesh.position.set(x, y + 0.05, z); // 바닥보다 살짝 위로 띄움
            mesh.rotation.set(...rotation);
            mesh.scale.set(...scale);
            scene.add(mesh);
        }

        function setupLabels() {
            // 치수 라벨 (중요도가 높으므로 가장 위에 렌더링되도록 y값 높임)
            createFixedLabel("정면 전체 너비: 10.0m", 0, 0.1, -10.5, { scale: [12, 3, 1], fontSize: 95 });
            createFixedLabel("5.0m (스크린 구역)", 1.75, 0.08, -7.8, { scale: [6, 1.5, 1], color: "#007AFF", fontSize: 80 });
            
            const line1 = new THREE.Mesh(new THREE.PlaneGeometry(0.04, 1.8), new THREE.MeshBasicMaterial({ color: 0x007AFF }));
            line1.rotation.x = -Math.PI / 2; line1.position.set(4.25, 0.04, -7.4); scene.add(line1);
            const line2 = new THREE.Mesh(new THREE.PlaneGeometry(0.04, 1.8), new THREE.MeshBasicMaterial({ color: 0x007AFF }));
            line2.rotation.x = -Math.PI / 2; line2.position.set(-0.75, 0.04, -7.4); scene.add(line2);

            createFixedLabel("3.5m (주방 구역)", -3.25, 0.08, -7.8, { scale: [6, 1.5, 1], color: "#D32F2F", fontSize: 80 });
            const line3 = new THREE.Mesh(new THREE.PlaneGeometry(0.04, 1.8), new THREE.MeshBasicMaterial({ color: 0xD32F2F }));
            line3.rotation.x = -Math.PI / 2; line3.position.set(-5.0, 0.04, -7.4); scene.add(line3);

            createFixedLabel("우측 전체 길이: 13.0m", 9.0, 0.1, 0, { scale: [12, 3, 1], rotation: [-Math.PI/2, 0, -Math.PI/2], fontSize: 95 });
            createFixedLabel("구간 1: 3.5m", 7.2, 0.08, -4.6, { rotation: [-Math.PI/2, 0, -Math.PI/2], color: "#E91E63", fontSize: 75 });
            createFixedLabel("구간 2: 7.5m", 7.2, 0.08, 2.0, { rotation: [-Math.PI/2, 0, -Math.PI/2], color: "#007AFF", fontSize: 75 });

            // 구역 라벨
            createFixedLabel("메인 스크린", 1.75, 0.06, -5.2, { color: "#007AFF", scale: [4, 1, 1], fontSize: 70 });
            createFixedLabel("주방 구역", -3.25, 0.06, -6.6, { color: "#D32F2F", scale: [3, 0.8, 1], fontSize: 65 });
            createFixedLabel("사이드 스크린 1", 3.8, 0.06, 0.5, { rotation: [-Math.PI/2, 0, -Math.PI/2], scale: [3.5, 0.9, 1], fontSize: 65 });
            createFixedLabel("사이드 스크린 2", 3.8, 0.06, 3.75, { rotation: [-Math.PI/2, 0, -Math.PI/2], scale: [3.5, 0.9, 1], fontSize: 65 });
            createFixedLabel("냉장고/정수기", -6.5, 0.06, -3.5, { rotation: [-Math.PI/2, 0, -Math.PI/2], scale: [4, 1, 1], fontSize: 70 });
            createFixedLabel("화장실 입구", -6.5, 0.06, 5.5, { rotation: [-Math.PI/2, 0, -Math.PI/2], color: "#0055aa", scale: [4, 1, 1], fontSize: 70 });
            
            // 하단 라벨 (최종 수정된 크기 및 문구)
            createFixedLabel("창고", -2.5, 0.09, 8.2, { scale: [3.5, 0.9, 1], fontSize: 80 });
            createFixedLabel("휴게실", -0.3, 0.09, 8.2, { scale: [4.5, 1.1, 1], color: "#444444", fontSize: 80 });
            createFixedLabel("조리대", 1.9, 0.09, 8.2, { scale: [3.5, 0.9, 1], fontSize: 80 });
            createFixedLabel("출입구", 3.5, 0.09, 8.2, { scale: [3.5, 0.9, 1], color: "#007AFF", fontSize: 80 });
        }

        function addDesk() {
            const group = new THREE.Group();
            const top = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.1, 1.2), new THREE.MeshStandardMaterial({ color: 0xffffff }));
            top.position.y = 0.75; top.castShadow = true; group.add(top);
            const legGeo = new THREE.BoxGeometry(0.1, 0.75, 0.1);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            [[1.1, 0.375, 0.5], [-1.1, 0.375, 0.5], [1.1, 0.375, -0.5], [-1.1, 0.375, -0.5]].forEach(p => {
                const leg = new THREE.Mesh(legGeo, legMat); leg.position.set(...p); group.add(leg);
            });
            const chairGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const chairMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
            [[0.6, 0.2, 0.8], [-0.6, 0.2, 0.8], [0.6, 0.2, -0.8], [-0.6, 0.2, -0.8]].forEach(p => {
                const chair = new THREE.Mesh(chairGeo, chairMat); chair.position.set(...p); group.add(chair);
            });
            group.position.set(0, 0, 0); group.userData.isDesk = true;
            const outline = new THREE.BoxHelper(group, 0x007AFF); outline.visible = false;
            group.add(outline); group.userData.outline = outline;
            scene.add(group); desks.push(group); selectDesk(group);
        }

        function selectDesk(obj) {
            if (selectedObject) selectedObject.userData.outline.visible = false;
            selectedObject = obj;
            if (selectedObject) selectedObject.userData.outline.visible = true;
        }

        function setupInteractions() {
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            document.addEventListener('wheel', (e) => { zoom = Math.max(10, Math.min(120, zoom + e.deltaY * 0.05)); });
        }

        function onMouseDown(e) {
            if (e.target.tagName === 'BUTTON') return;
            isMouseDown = true;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(desks, true);
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && !obj.userData.isDesk) obj = obj.parent;
                if (obj.userData.isDesk) { selectDesk(obj); isDragging = true; }
            } else { selectDesk(null); }
        }

        function onMouseUp() { isMouseDown = false; isDragging = false; }

        function onMouseMove(e) {
            if (isDragging && selectedObject) {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersectionPoint = new THREE.Vector3();
                if (raycaster.ray.intersectPlane(planeForDragging, intersectionPoint)) {
                    selectedObject.position.x = Math.max(-4.5, Math.min(4.5, intersectionPoint.x));
                    selectedObject.position.z = Math.max(-6, Math.min(6, intersectionPoint.z));
                    selectedObject.userData.outline.update();
                }
            } else if (isMouseDown) {
                targetRotationY += e.movementX * 0.005;
                targetRotationX += e.movementY * 0.005;
                targetRotationX = Math.max(0.1, Math.min(Math.PI/2, targetRotationX));
            }
        }

        function onKeyDown(e) {
            if (!selectedObject) return;
            if (e.key.toLowerCase() === 'r') { selectedObject.rotation.y += Math.PI / 4; selectedObject.userData.outline.update(); }
            if (e.key === 'Delete' || e.key === 'Backspace') {
                scene.remove(selectedObject);
                const index = desks.indexOf(selectedObject);
                if (index > -1) desks.splice(index, 1);
                selectedObject = null;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const targetPos = new THREE.Vector3(
                zoom * Math.sin(targetRotationY) * Math.cos(targetRotationX),
                zoom * Math.sin(targetRotationX),
                zoom * Math.cos(targetRotationY) * Math.cos(targetRotationX)
            );
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(0, 0, 0);
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>
